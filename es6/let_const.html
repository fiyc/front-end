<html>
<head>
<title>ES6 let & const </title>
<meta charset="UTF-8" />
<meta name="Author" content="fiyc" />
<meta name="Description" content="" />

</head>
<body>
<script type="text/javascript">
	// let声明的变量只在它所在的代码块有效
	function Demo1(){
		{
			let a = 10;
			var b = 1;
		}	

		console.log(b);
		console.log(a);
	}

	// for循环的计数器，就很合适使用let命令
	function Demo2(){
		for(let i = 0; i < 10; i++){
			console.log(i);
		}

		console.log(i);
	}

	// for循环使用var
	function Demo3(){
		var a = [];
		for(var i = 0; i < 10; i++){
			console.log(i);
		}

		console.log(i);
	}

	// for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域
	function Demo4(){
		for(let i = 0; i < 10; i++){
			let i = 'abc';
			console.log(i);
		}
	}

	//不存在变量提升 
	function Demo5(){
		console.log(foo);

		var foo = 1;

		console.log(bar);

		let bar = 1;
	}

	// 如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。
	function Demo6(){
		let temp = 123;

		if(true){
			temp = 456;
			let temp;
		}
	}

	// “暂时性死区”也意味着typeof不再是一个百分之百安全的操作。
	function Demo7(){
		let temp = 'abc';

		if(true){
			let a = typeof temp;

			let temp;
		}
	}

	// let不允许在相同作用域内，重复声明同一个变量。
	function Demo8(){
		let a = 1;
		let a = 2;
	}

	// let实际上为 JavaScript 新增了块级作用域。
	function Demo9(){
		let n = 5;
		if(true){
			let n = 6;
		}

		console.log(n);
	}

	// const声明一个只读的常量。一旦声明，常量的值就不能改变。
	function Demo10(){
		const a = 10;

		a = 11;
	}

	// const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动
	function Demo11(){
		const a = {};

		a.name = "hello";
		a.age = 12;

		console.log(a);
	}

	// 如果真的想将对象冻结，应该使用Object.freeze方法。
	function Demo12(){
		const a = Object.freeze({});
		a.name = "hello";
		console.log(a);
	}

	// 下面是一个将对象彻底冻结的函数
	function Demo13(){
		var constantize = (obj) => {
			Object.freeze(obj);	
			Object.keys(obj).forEach((key, i) => {
				if( typeof obj[key] == 'object'){
					constantize(obj[key]);
				}
			});

			return obj;
		}


		const a = constantize({'name': "fiyc", 'age': 23, 'info':{'xxx':"yyy", 'bbb':"aaaa"}});
		console.log(a);
		a.info.xxx = 'aaa';
		console.log(a);
	}



</script>	
</body>
</html>
	